---
title: Настройка Vite
---

# Настройка Vite

При запуске `vite` из командной строки Vite автоматически попытается разрешить файл конфигурации с именем `vite.config.js` внутри [корня проекта](/guide/#index-html-and-project-root) (также поддерживаются другие расширения JS и TS).

Самый простой файл конфигурации выглядит так:

```js [vite.config.js]
export default {
  // опции конфигурации
}
```

Обратите внимание, что Vite поддерживает использование синтаксиса ES модулей в файле конфигурации, даже если проект не использует нативный Node ESM, например, `type: "module"` в `package.json`. В этом случае файл конфигурации автоматически предварительно обрабатывается перед загрузкой.

Вы также можете явно указать файл конфигурации для использования с помощью опции CLI `--config` (разрешается относительно `cwd`):

```bash
vite --config my-config.js
```

::: tip ЗАГРУЗКА КОНФИГУРАЦИИ
По умолчанию Vite использует `esbuild` для упаковки конфигурации в временный файл и загрузки его. Это может вызвать проблемы при импорте файлов TypeScript в монорепозитории. Если вы столкнетесь с какими-либо проблемами с этим подходом, вы можете указать `--configLoader runner`, чтобы использовать [модульный загрузчик](/guide/api-environment-runtimes.html#modulerunner) вместо этого, который не создаст временную конфигурацию и будет преобразовывать любые файлы на лету. Обратите внимание, что модульный загрузчик не поддерживает CJS в файлах конфигурации, но внешние CJS пакеты должны работать как обычно.

Кроме того, если вы используете среду, которая поддерживает TypeScript (например, `node --experimental-strip-types`), или если вы пишете только обычный JavaScript, вы можете указать `--configLoader native`, чтобы использовать нативный загрузчик среды для загрузки файла конфигурации. Обратите внимание, что обновления модулей, импортируемых файлом конфигурации, не обнаруживаются и, следовательно, не перезапускают сервер Vite автоматически.
:::

## Интеллектуальная подсказка конфигурации

Поскольку Vite поставляется с типами TypeScript, вы можете использовать интеллектуальную подсказку вашего IDE с подсказками типа jsdoc:

```js
/** @type {import('vite').UserConfig} */
export default {
  // ...
}
```

В качестве альтернативы вы можете использовать вспомогательную функцию `defineConfig`, которая должна предоставить интеллектуальную подсказку без необходимости аннотаций jsdoc:

```js
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
})
```

Vite также поддерживает файлы конфигурации TypeScript. Вы можете использовать `vite.config.ts` с вышеупомянутой функцией `defineConfig` или с оператором `satisfies`:

```ts
import type { UserConfig } from 'vite'

export default {
  // ...
} satisfies UserConfig
```

## Условная конфигурация

Если конфигурация должна условно определять параметры в зависимости от команды (`serve` или `build`), используемого [режима](/guide/env-and-mode#modes), является ли это сборкой SSR (`isSsrBuild`) или предварительным просмотром сборки (`isPreview`), она может экспортировать функцию вместо этого:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
  if (command === 'serve') {
    return {
      // конфигурация для разработки
    }
  } else {
    // command === 'build'
    return {
      // конфигурация для сборки
    }
  }
})
```

Важно отметить, что в API Vite значение `command` равно `serve` во время разработки (в cli [`vite`](/guide/cli#vite), `vite dev` и `vite serve` являются псевдонимами), и `build` при сборке для продакшена ([`vite build`](/guide/cli#vite-build)).

`isSsrBuild` и `isPreview` — это дополнительные необязательные флаги для различения типа команд `build` и `serve` соответственно. Некоторые инструменты, которые загружают конфигурацию Vite, могут не поддерживать эти флаги и передадут `undefined` вместо этого. Поэтому рекомендуется использовать явное сравнение с `true` и `false`.

## Асинхронная конфигурация

Если конфигурации необходимо вызывать асинхронные функции, она может экспортировать асинхронную функцию вместо этого. И эта асинхронная функция также может быть передана через `defineConfig` для улучшенной поддержки интеллектуальной подсказки:

```js twoslash
import { defineConfig } from 'vite'
// ---cut---
export default defineConfig(async ({ command, mode }) => {
  const data = await asyncFunction()
  return {
    // конфигурация vite
  }
})
```

## Использование переменных окружения в конфигурации

Переменные окружения можно получить из `process.env`, как обычно.

Обратите внимание, что Vite не загружает файлы `.env` по умолчанию, так как файлы для загрузки можно определить только после оценки конфигурации Vite, например, параметры `root` и `envDir` влияют на поведение загрузки. Однако вы можете использовать экспортированную вспомогательную функцию `loadEnv`, чтобы загрузить конкретный файл `.env`, если это необходимо.

```js twoslash
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  // Загрузить файл env на основе `mode` в текущем рабочем каталоге.
  // Установите третий параметр в '' для загрузки всех env независимо от
  // префикса `VITE_`.
  const env = loadEnv(mode, process.cwd(), '')
  return {
    // конфигурация vite
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
  }
})
```

## Отладка файла конфигурации в VS Code

С поведением по умолчанию `--configLoader bundle` Vite записывает сгенерированный временный файл конфигурации в папку `node_modules/.vite-temp`, и ошибка "файл не найден" произойдет при установке точки останова для отладки в файле конфигурации Vite. Чтобы исправить эту проблему, добавьте следующую конфигурацию в `.vscode/settings.json`:

```json
{
  "debug.javascript.terminalOptions": {
    "resolveSourceMapLocations": [
      "${workspaceFolder}/**",
      "!**/node_modules/**",
      "**/node_modules/.vite-temp/**"
    ]
  }
}
```
