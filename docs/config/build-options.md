# Опции сборки

Если не указано иное, опции в этом разделе применяются только к сборке.

## build.target

- **Тип:** `string | string[]`
- **По умолчанию:** `'modules'`
- **Связано:** [Совместимость с браузерами](/guide/build#browser-compatibility)

Цель совместимости браузеров для финального бандла. Значение по умолчанию — специальное значение Vite, `'modules'`, которое нацелено на браузеры с поддержкой [нативных ES модулей](https://caniuse.com/es6-module), [нативного динамического импорта ESM](https://caniuse.com/es6-module-dynamic-import) и [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Vite заменит `'modules'` на `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`.

Еще одно специальное значение — `'esnext'` — предполагает поддержку нативных динамических импортов и будет выполнять минимальное транспилирование.

Трансформация выполняется с помощью esbuild, и значение должно быть допустимой [опцией цели esbuild](https://esbuild.github.io/api/#target). Пользовательские цели могут быть либо версией ES (например, `es2015`), браузером с версией (например, `chrome58`), либо массивом нескольких строк целей.

Обратите внимание, что сборка завершится неудачей, если код содержит функции, которые не могут быть безопасно транспилированы esbuild. Смотрите [документацию esbuild](https://esbuild.github.io/content-types/#javascript) для получения дополнительных сведений.

## build.modulePreload

- **Тип:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`
- **По умолчанию:** `{ polyfill: true }`

По умолчанию автоматически вставляется [полифилл для предварительной загрузки модулей](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill). Полифилл автоматически вставляется в прокси-модуль каждого `index.html` входа. Если сборка настроена на использование нестандартного HTML-входа через `build.rollupOptions.input`, то необходимо вручную импортировать полифилл в вашем пользовательском входе:

```js
import 'vite/modulepreload-polyfill'
```

Примечание: полифилл **не** применяется в [Режиме библиотеки](/guide/build#library-mode). Если вам нужно поддерживать браузеры без нативного динамического импорта, вам, вероятно, следует избегать его использования в вашей библиотеке.

Полифилл можно отключить, установив `{ polyfill: false }`.

Список чанков для предварительной загрузки для каждого динамического импорта вычисляется Vite. По умолчанию будет использоваться абсолютный путь, включая `base`, при загрузке этих зависимостей. Если `base` относительный (`''` или `'./'`), то `import.meta.url` используется во время выполнения, чтобы избежать абсолютных путей, зависящих от окончательной развернутой базы.

Существует экспериментальная поддержка тонкой настройки списка зависимостей и их путей с помощью функции `resolveDependencies`. [Оставьте отзыв](https://github.com/vitejs/vite/discussions/13841). Она ожидает функцию типа `ResolveModulePreloadDependenciesFn`:

```ts
type ResolveModulePreloadDependenciesFn = (
  url: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]
```

Функция `resolveDependencies` будет вызываться для каждого динамического импорта со списком зависимостей, от которых он зависит, и также будет вызываться для каждого чанка, импортированного в файлы HTML входа. Можно вернуть новый массив зависимостей с этими отфильтрованными или добавленными зависимостями и измененными путями. Пути `deps` относительны к `build.outDir`. Возвращаемое значение должно быть относительным путем к `build.outDir`.

```js twoslash
/** @type {import('vite').UserConfig} */
const config = {
  // prettier-ignore
  build: {
// ---cut-before---
modulePreload: {
  resolveDependencies: (filename, deps, { hostId, hostType }) => {
    return deps.filter(condition)
  },
},
// ---cut-after---
  },
}
```

Разрешенные пути зависимостей можно дополнительно изменить с помощью [`experimental.renderBuiltUrl`](../guide/build.md#advanced-base-options).

## build.polyfillModulePreload

- **Тип:** `boolean`
- **По умолчанию:** `true`
- **Устарело:** используйте `build.modulePreload.polyfill` вместо этого

Следует ли автоматически вставлять [полифилл для предварительной загрузки модулей](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).

## build.outDir

- **Тип:** `string`
- **По умолчанию:** `dist`

Укажите выходной каталог (относительно [корня проекта](/guide/#index-html-and-project-root)).

## build.assetsDir

- **Тип:** `string`
- **По умолчанию:** `assets`

Укажите каталог для вложения сгенерированных ресурсов (относительно `build.outDir`. Это не используется в [Режиме библиотеки](/guide/build#library-mode)).

## build.assetsInlineLimit

- **Тип:** `number` | `((filePath: string, content: Buffer) => boolean | undefined)`
- **По умолчанию:** `4096` (4 KiB)

Импортированные или упомянутые ресурсы, которые меньше этого порога, будут встроены как base64 URL, чтобы избежать дополнительных http-запросов. Установите в `0`, чтобы полностью отключить встраивание.

Если передан обратный вызов, можно вернуть логическое значение, чтобы включить или исключить. Если ничего не возвращается, применяется логика по умолчанию.

Заполнители Git LFS автоматически исключаются из встраивания, поскольку они не содержат содержимого файла, который они представляют.

::: tip Примечание
Если вы укажете `build.lib`, `build.assetsInlineLimit` будет проигнорирован, и ресурсы всегда будут встроены, независимо от размера файла или того, являются ли они заполнителями Git LFS.
:::

## build.cssCodeSplit

- **Тип:** `boolean`
- **По умолчанию:** `true`

Включить/отключить разделение кода CSS. Когда включено, CSS, импортированный в асинхронные JS чанки, будет сохранен как чанки и загружен вместе с загружаемым чанком.

Если отключено, весь CSS в проекте будет извлечен в один файл CSS.

::: tip Примечание
Если вы укажете `build.lib`, `build.cssCodeSplit` будет `false` по умолчанию.
:::

## build.cssTarget

- **Тип:** `string | string[]`
- **По умолчанию:** то же, что и [`build.target`](#build-target)

Эта опция позволяет пользователям установить другую цель браузера для минификации CSS, отличную от той, которая используется для транспиляции JavaScript.

Она должна использоваться только в случае, если вы нацеливаетесь на неосновной браузер.
Один из примеров — Android WeChat WebView, который поддерживает большинство современных функций JavaScript, но не [`#RGBA` шестнадцатеричное обозначение цвета в CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors).
В этом случае вам нужно установить `build.cssTarget` в `chrome61`, чтобы предотвратить преобразование `rgba()` цветов в шестнадцатеричные обозначения `#RGBA`.

## build.cssMinify

- **Тип:** `boolean | 'esbuild' | 'lightningcss'`
- **По умолчанию:** то же, что и [`build.minify`](#build-minify) для клиента, `'esbuild'` для SSR

Эта опция позволяет пользователям переопределить минификацию CSS, вместо того чтобы по умолчанию использовать `build.minify`, так что вы можете настраивать минификацию для JS и CSS отдельно. Vite по умолчанию использует `esbuild` для минификации CSS. Установите опцию в `'lightningcss'`, чтобы использовать [Lightning CSS](https://lightningcss.dev/minification.html) вместо этого. Если выбрано, это можно настроить с помощью [`css.lightningcss`](./shared-options.md#css-lightningcss).

## build.sourcemap

- **Тип:** `boolean | 'inline' | 'hidden'`
- **По умолчанию:** `false`

Генерировать sourcemaps для продакшена. Если `true`, будет создан отдельный файл sourcemap. Если `'inline'`, sourcemap будет добавлен к результирующему выходному файлу как data URI. `'hidden'` работает как `true`, за исключением того, что соответствующие комментарии sourcemap в упакованных файлах подавляются.

## build.rollupOptions

- **Тип:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

Прямо настраивайте внутреннюю сборку Rollup. Это те же опции, которые могут быть экспортированы из файла конфигурации Rollup и будут объединены с внутренними опциями Rollup Vite. Смотрите [документацию по опциям Rollup](https://rollupjs.org/configuration-options/) для получения дополнительных сведений.

## build.commonjsOptions

- **Тип:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

Опции, которые передаются [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).

## build.dynamicImportVarsOptions

- **Тип:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
- **Связано:** [Динамический импорт](/guide/features#dynamic-import)

Опции, которые передаются [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).

## build.lib

- **Тип:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string), cssFileName?: string }`
- **Связано:** [Режим библиотеки](/guide/build#library-mode)

Сборка как библиотека. `entry` обязателен, так как библиотека не может использовать HTML в качестве входа. `name` — это экспортируемая глобальная переменная и обязательна, когда `formats` включает `'umd'` или `'iife'`. Значения по умолчанию для `formats` — `['es', 'umd']`, или `['es', 'cjs']`, если используются несколько входов.

`fileName` — это имя выходного файла пакета, которое по умолчанию соответствует `"name"` в `package.json`. Его также можно определить как функцию, принимающую `format` и `entryName` в качестве аргументов и возвращающую имя файла.

Если ваш пакет импортирует CSS, `cssFileName` можно использовать для указания имени выходного файла CSS. По умолчанию оно совпадает с тем же значением, что и `fileName`, если оно установлено как строка, в противном случае оно также возвращается к `"name"` в `package.json`.

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})
```

## build.manifest

- **Тип:** `boolean | string`
- **По умолчанию:** `false`
- **Связано:** [Интеграция с бэкендом](/guide/backend-integration)

Следует ли генерировать файл манифеста, который содержит отображение неназванных имен файлов активов на их хэшированные версии, которые затем могут быть использованы серверным фреймворком для рендеринга правильных ссылок на активы.

Когда значение является строкой, оно будет использоваться как путь к файлу манифеста относительно `build.outDir`. Когда установлено в `true`, путь будет `.vite/manifest.json`.

## build.ssrManifest

- **Тип:** `boolean | string`
- **По умолчанию:** `false`
- **Связано:** [Серверный рендеринг](/guide/ssr)

Следует ли генерировать файл манифеста SSR для определения ссылок на стили и директив предварительной загрузки активов в продакшене.

Когда значение является строкой, оно будет использоваться как путь к файлу манифеста относительно `build.outDir`. Когда установлено в `true`, путь будет `.vite/ssr-manifest.json`.

## build.ssr

- **Тип:** `boolean | string`
- **По умолчанию:** `false`
- **Связано:** [Серверный рендеринг](/guide/ssr)

Производить сборку, ориентированную на SSR. Значение может быть строкой для прямого указания входа SSR или `true`, что требует указания входа SSR через `rollupOptions.input`.

## build.emitAssets

- **Тип:** `boolean`
- **По умолчанию:** `false`

Во время сборки, не относящейся к клиенту, статические активы не выводятся, так как предполагается, что они будут выведены как часть клиентской сборки. Эта опция позволяет фреймворкам принудительно выводить их в других средах сборки. Ответственность за объединение активов лежит на фреймворке в процессе постобработки.

## build.ssrEmitAssets

- **Тип:** `boolean`
- **По умолчанию:** `false`

Во время сборки SSR статические активы не выводятся, так как предполагается, что они будут выведены как часть клиентской сборки. Эта опция позволяет фреймворкам принудительно выводить их как в клиентской, так и в сборке SSR. Ответственность за объединение активов лежит на фреймворке в процессе постобработки. Эта опция будет заменена на `build.emitAssets`, как только API окружений станет стабильным.

## build.minify

- **Тип:** `boolean | 'terser' | 'esbuild'`
- **По умолчанию:** `'esbuild'` для клиентской сборки, `false` для сборки SSR

Установите в `false`, чтобы отключить минификацию, или укажите минификатор для использования. По умолчанию используется [esbuild](https://github.com/evanw/esbuild), который в 20 ~ 40 раз быстрее, чем terser, и только на 1 ~ 2% хуже по сжатию. [Бенчмарки](https://github.com/privatenumber/minification-benchmarks)

Обратите внимание, что опция `build.minify` не минифицирует пробелы при использовании формата `'es'` в режиме библиотеки, так как она удаляет аннотации чистоты и нарушает дерево-шейкинг.

Terser должен быть установлен, когда он установлен в `'terser'`.

```sh
npm add -D terser
```

## build.terserOptions

- **Тип:** `TerserOptions`

Дополнительные [опции минификации](https://terser.org/docs/api-reference#minify-options), которые передаются Terser.

Кроме того, вы также можете передать опцию `maxWorkers: number`, чтобы указать максимальное количество рабочих процессов для создания. По умолчанию это количество ЦП минус 1.

## build.write

- **Тип:** `boolean`
- **По умолчанию:** `true`

Установите в `false`, чтобы отключить запись бандла на диск. Это в основном используется в [программных вызовах `build()`](/guide/api-javascript#build), где требуется дальнейшая постобработка бандла перед записью на диск.

## build.emptyOutDir

- **Тип:** `boolean`
- **По умолчанию:** `true`, если `outDir` находится внутри `root`

По умолчанию Vite очистит `outDir` при сборке, если он находится внутри корня проекта. Он выдаст предупреждение, если `outDir` находится вне корня, чтобы избежать случайного удаления важных файлов. Вы можете явно установить эту опцию, чтобы подавить предупреждение. Это также доступно через командную строку как `--emptyOutDir`.

## build.copyPublicDir

- **Тип:** `boolean`
- **По умолчанию:** `true`

По умолчанию Vite скопирует файлы из `publicDir` в `outDir` при сборке. Установите в `false`, чтобы отключить это.

## build.reportCompressedSize

- **Тип:** `boolean`
- **По умолчанию:** `true`

Включить/отключить отчет о размере, сжатом с помощью gzip. Сжатие больших выходных файлов может быть медленным, поэтому отключение этого может увеличить производительность сборки для больших проектов.

## build.chunkSizeWarningLimit

- **Тип:** `number`
- **По умолчанию:** `500`

Предел для предупреждений о размере чанка (в кБ). Он сравнивается с несжатыми размерами чанков, так как [размер JavaScript сам по себе связан со временем выполнения](https://v8.dev/blog/cost-of-javascript-2019).

## build.watch

- **Тип:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch)`| null`
- **По умолчанию:** `null`

Установите в `{}` для включения наблюдателя rollup. Это в основном используется в случаях, связанных со сборочными плагинами или процессами интеграции.

::: warning Использование Vite в Windows Subsystem for Linux (WSL) 2

Существуют случаи, когда наблюдение за файловой системой не работает с WSL2.
Смотрите [`server.watch`](./server-options.md#server-watch) для получения дополнительных сведений.

:::
