# API окружений для плагинов

:::warning Экспериментально
API окружений является экспериментальным. Мы будем поддерживать API стабильным во время Vite 6, чтобы позволить экосистеме экспериментировать и строить на его основе. Мы планируем стабилизировать эти новые API с потенциальными breaking changes в Vite 7.

Ресурсы:

- [Обсуждение обратной связи](https://github.com/vitejs/vite/discussions/16358), где мы собираем отзывы о новых API.
- [PR API окружений](https://github.com/vitejs/vite/pull/16471), где новые API были реализованы и проверены.

Пожалуйста, поделитесь с нами вашими отзывами.
:::

## Доступ к текущему окружению в хуках

Учитывая, что до Vite 6 было только два окружения (`client` и `ssr`), булево значение `ssr` было достаточно для идентификации текущего окружения в API Vite. Хуки плагинов получали булево значение `ssr` в последнем параметре options, и несколько API ожидали необязательный последний параметр `ssr` для правильной ассоциации модулей с соответствующим окружением (например, `server.moduleGraph.getModuleByUrl(url, { ssr })`).

С появлением настраиваемых окружений у нас теперь есть единый способ доступа к их опциям и экземплярам в плагинах. Хуки плагинов теперь раскрывают `this.environment` в их контексте, а API, которые ранее ожидали булево значение `ssr`, теперь привязаны к соответствующему окружению (например, `environment.moduleGraph.getModuleByUrl(url)`).

Сервер Vite имеет общий конвейер плагинов, но когда модуль обрабатывается, это всегда происходит в контексте заданного окружения. Экземпляр `environment` доступен в контексте плагина.

Плагин может использовать экземпляр `environment` для изменения способа обработки модуля в зависимости от конфигурации окружения (к которой можно получить доступ с помощью `environment.config`).

```ts
  transform(code, id) {
    console.log(this.environment.config.resolve.conditions)
  }
```

## Регистрация новых окружений с помощью хуков

Плагины могут добавлять новые окружения в хуке `config` (например, чтобы иметь отдельный граф модулей для [RSC](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)):

```ts
  config(config: UserConfig) {
    config.environments.rsc ??= {}
  }
```

Пустого объекта достаточно для регистрации окружения, значения по умолчанию берутся из конфигурации окружения корневого уровня.

## Настройка окружения с помощью хуков

Пока выполняется хук `config`, полный список окружений еще не известен, и на окружения могут влиять как значения по умолчанию из конфигурации окружения корневого уровня, так и явно через запись `config.environments`.
Плагины должны устанавливать значения по умолчанию с помощью хука `config`. Для настройки каждого окружения они могут использовать новый хук `configEnvironment`. Этот хук вызывается для каждого окружения с его частично разрешенной конфигурацией, включая разрешение окончательных значений по умолчанию.

```ts
  configEnvironment(name: string, options: EnvironmentOptions) {
    if (name === 'rsc') {
      options.resolve.conditions = // ...
```

## Хук `hotUpdate`

- **Тип:** `(this: { environment: DevEnvironment }, options: HotUpdateOptions) => Array<EnvironmentModuleNode> | void | Promise<Array<EnvironmentModuleNode> | void>`
- **См. также:** [API HMR](./api-hmr)

Хук `hotUpdate` позволяет плагинам выполнять пользовательскую обработку обновлений HMR для заданного окружения. Когда файл изменяется, алгоритм HMR выполняется для каждого окружения последовательно в соответствии с порядком в `server.environments`, поэтому хук `hotUpdate` будет вызываться несколько раз. Хук получает объект контекста со следующей сигнатурой:

```ts
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

- `this.environment` - это среда выполнения модулей, где в данный момент обрабатывается обновление файла.

- `modules` - это массив модулей в этом окружении, на которые влияет измененный файл. Это массив, потому что один файл может соответствовать нескольким обслуживаемым модулям (например, Vue SFC).

- `read` - это асинхронная функция чтения, которая возвращает содержимое файла. Это предоставляется потому, что на некоторых системах callback изменения файла может сработать слишком быстро, прежде чем редактор закончит обновление файла, и прямой `fs.readFile` вернет пустое содержимое. Функция чтения, которая передается, нормализует это поведение.

Хук может выбрать:

- Фильтрацию и сужение списка затронутых модулей, чтобы HMR был более точным.

- Возврат пустого массива и выполнение полной перезагрузки:

  ```js
  hotUpdate({ modules, timestamp }) {
    if (this.environment.name !== 'client')
      return

    // Инвалидируем модули вручную
    const invalidatedModules = new Set()
    for (const mod of modules) {
      this.environment.moduleGraph.invalidateModule(
        mod,
        invalidatedModules,
        timestamp,
        true
      )
    }
    this.environment.hot.send({ type: 'full-reload' })
    return []
  }
  ```

- Возврат пустого массива и выполнение полностью пользовательской обработки HMR путем отправки пользовательских событий клиенту:

  ```js
  hotUpdate() {
    if (this.environment.name !== 'client')
      return

    this.environment.hot.send({
      type: 'custom',
      event: 'special-update',
      data: {}
    })
    return []
  }
  ```

  Клиентский код должен зарегистрировать соответствующий обработчик с помощью [API HMR](./api-hmr) (это может быть внедрено тем же плагином через хук `transform`):

  ```js
  if (import.meta.hot) {
    import.meta.hot.on('special-update', (data) => {
      // выполнить пользовательское обновление
    })
  }
  ```

## Плагины для каждого окружения

Плагин может определить, к каким окружениям он должен применяться, с помощью функции `applyToEnvironment`.

```js
const UnoCssPlugin = () => {
  // общее глобальное состояние
  return {
    buildStart() {
      // инициализация состояния для каждого окружения с WeakMap<Environment,Data>
      // используя this.environment
    },
    configureServer() {
      // используем глобальные хуки как обычно
    },
    applyToEnvironment(environment) {
      // возвращаем true, если этот плагин должен быть активен в этом окружении,
      // или возвращаем новый плагин для его замены.
      // если хук не используется, плагин активен во всех окружениях
    },
    resolveId(id, importer) {
      // вызывается только для окружений, к которым применяется этот плагин
    },
  }
}
```

Если плагин не учитывает окружения и имеет состояние, которое не привязано к текущему окружению, хук `applyToEnvironment` позволяет легко сделать его специфичным для каждого окружения.

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    {
      name: 'per-environment-plugin',
      applyToEnvironment(environment) {
        return nonShareablePlugin({ outputName: environment.name })
      },
    },
  ],
})
```

Vite экспортирует вспомогательную функцию `perEnvironmentPlugin` для упрощения этих случаев, когда не требуются другие хуки:

```js
import { nonShareablePlugin } from 'non-shareable-plugin'

export default defineConfig({
  plugins: [
    perEnvironmentPlugin('per-environment-plugin', (environment) =>
      nonShareablePlugin({ outputName: environment.name }),
    ),
  ],
})
```

## Окружение в хуках сборки

Так же, как и во время разработки, хуки плагинов также получают экземпляр окружения во время сборки, заменяя булево значение `ssr`.
Это также работает для `renderChunk`, `generateBundle` и других хуков, специфичных для сборки.

## Общие плагины во время сборки

До Vite 6 конвейеры плагинов работали по-разному во время разработки и сборки:

- **Во время разработки:** плагины общие
- **Во время сборки:** плагины изолированы для каждого окружения (в разных процессах: `vite build`, затем `vite build --ssr`).

Это вынуждало фреймворки делиться состоянием между сборкой `client` и сборкой `ssr` через файлы манифеста, записанные в файловую систему. В Vite 6 мы теперь собираем все окружения в одном процессе, поэтому способ работы конвейера плагинов и межокруженческой коммуникации может быть согласован с разработкой.

В будущем мажорном релизе (Vite 7 или 8) мы стремимся к полному согласованию:

- **Во время разработки и сборки:** плагины общие, с [фильтрацией для каждого окружения](#per-environment-plugins)

Также будет один общий экземпляр `ResolvedConfig` во время сборки, позволяющий кэшировать на уровне всего процесса сборки приложения так же, как мы делали это с `WeakMap<ResolvedConfig, CachedData>` во время разработки.

Для Vite 6 нам нужно сделать меньший шаг для сохранения обратной совместимости. Плагины экосистемы в настоящее время используют `config.build` вместо `environment.config.build` для доступа к конфигурации, поэтому нам нужно создавать новый `ResolvedConfig` для каждого окружения по умолчанию. Проект может включить общий доступ к полной конфигурации и конвейеру плагинов, установив `builder.sharedConfigBuild` в `true`.

Эта опция будет работать только для небольшого подмножества проектов изначально, поэтому авторы плагинов могут включить общий доступ для конкретного плагина, установив флаг `sharedDuringBuild` в `true`. Это позволяет легко делиться состоянием как для обычных плагинов:

```js
function myPlugin() {
  // Делимся состоянием между всеми окружениями в разработке и сборке
  const sharedState = ...
  return {
    name: 'shared-plugin',
    transform(code, id) { ... },

    // Включаем один экземпляр для всех окружений
    sharedDuringBuild: true,
  }
}
```
