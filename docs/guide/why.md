# Почему Vite

## Проблемы

До того, как ES модули стали доступны в браузерах, у разработчиков не было нативного механизма для написания JavaScript в модульном стиле. Именно поэтому мы все знакомы с концепцией "бандлинга": использованием инструментов, которые сканируют, обрабатывают и объединяют наши исходные модули в файлы, которые могут работать в браузере.

Со временем мы увидели инструменты, такие как [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) и [Parcel](https://parceljs.org/), которые значительно улучшили опыт разработки для фронтенд-разработчиков.

Однако, по мере того, как мы создаем все более амбициозные приложения, количество JavaScript, с которым мы работаем, также резко увеличивается. Не редкость, когда крупномасштабные проекты содержат тысячи модулей. Мы начинаем сталкиваться с узким местом производительности для инструментов на основе JavaScript: часто может потребоваться неоправданно долгое ожидание (иногда до нескольких минут!) для запуска dev-сервера, и даже с Hot Module Replacement (HMR) изменения файлов могут занимать несколько секунд, чтобы отразиться в браузере. Медленный цикл обратной связи может сильно влиять на продуктивность и удовлетворенность разработчиков.

Vite стремится решить эти проблемы, используя новые достижения в экосистеме: доступность нативных ES модулей в браузере и появление JavaScript-инструментов, написанных на языках, компилируемых в нативный код.

### Медленный запуск сервера

При холодном запуске dev-сервера настройка сборки на основе бандлера должна сначала сканировать и собрать все приложение, прежде чем оно может быть обслужено.

Vite улучшает время запуска dev-сервера, сначала разделяя модули в приложении на две категории: **зависимости** и **исходный код**.

- **Зависимости** - это в основном простой JavaScript, который не часто меняется во время разработки. Некоторые большие зависимости (например, библиотеки компонентов с сотнями модулей) также довольно дороги в обработке. Зависимости также могут поставляться в различных форматах модулей (например, ESM или CommonJS).

  Vite [предварительно собирает зависимости](./dep-pre-bundling.md) с помощью [esbuild](https://esbuild.github.io/). esbuild написан на Go и предварительно собирает зависимости в 10-100 раз быстрее, чем бандлеры на основе JavaScript.

- **Исходный код** часто содержит не простой JavaScript, который требует преобразования (например, JSX, CSS или компоненты Vue/Svelte), и будет редактироваться очень часто. Также не весь исходный код нужно загружать одновременно (например, при разделении кода на основе маршрутов).

  Vite обслуживает исходный код через [нативный ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). По сути, это позволяет браузеру взять на себя часть работы бандлера: Vite нужно только преобразовывать и обслуживать исходный код по требованию, когда браузер его запрашивает. Код за условными динамическими импортами обрабатывается только если он фактически используется на текущем экране.

<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>
<svg-image :svg="bundlerSvg" />
<svg-image :svg="esmSvg" />

### Медленные обновления

Когда файл редактируется в настройке сборки на основе бандлера, неэффективно пересобирать весь бандл по очевидной причине: скорость обновления будет ухудшаться линейно с размером приложения.

В некоторых бандлерах dev-сервер выполняет сборку в памяти, так что ему нужно только инвалидировать часть графа модулей при изменении файла, но ему все равно нужно перестраивать весь бандл и перезагружать веб-страницу. Перестроение бандла может быть дорогим, а перезагрузка страницы уничтожает текущее состояние приложения. Вот почему некоторые бандлеры поддерживают Hot Module Replacement (HMR): позволяя модулю "горячо заменять" себя, не затрагивая остальную часть страницы. Это значительно улучшает DX - однако на практике мы обнаружили, что даже скорость обновления HMR значительно ухудшается по мере роста размера приложения.

В Vite HMR выполняется через нативный ESM. Когда файл редактируется, Vite нужно только точно инвалидировать цепочку между отредактированным модулем и его ближайшей границей HMR (в большинстве случаев только сам модуль), что делает обновления HMR постоянно быстрыми независимо от размера вашего приложения.

Vite также использует HTTP-заголовки для ускорения полной перезагрузки страницы (снова, позволяя браузеру делать больше работы за нас): запросы модулей исходного кода делаются условными через `304 Not Modified`, а запросы модулей зависимостей сильно кэшируются через `Cache-Control: max-age=31536000,immutable`, так что они не попадают на сервер снова после кэширования.

Как только вы испытаете, насколько быстр Vite, мы очень сомневаемся, что вы захотите снова мириться с разработкой на основе бандлинга.

## Почему сборка для продакшена

Несмотря на то, что нативный ESM теперь широко поддерживается, поставка несобранного ESM в продакшен все еще неэффективна (даже с HTTP/2) из-за дополнительных сетевых обходов, вызванных вложенными импортами. Для получения оптимальной производительности загрузки в продакшене все еще лучше собирать ваш код с tree-shaking, ленивой загрузкой и разделением общих чанков (для лучшего кэширования).

Обеспечение оптимального вывода и согласованности поведения между dev-сервером и продакшен-сборкой непросто. Вот почему Vite поставляется с предварительно настроенной [командой сборки](./build.md), которая включает множество [оптимизаций производительности](./features.md#build-optimizations) "из коробки".

## Почему не сборка с esbuild?

Хотя Vite использует esbuild для [предварительной сборки некоторых зависимостей в dev](./dep-pre-bundling.md), Vite не использует esbuild как бандлер для продакшен-сборок.

Текущий API плагинов Vite несовместим с использованием `esbuild` как бандлера. Несмотря на то, что `esbuild` быстрее, принятие Vite гибкого API плагинов и инфраструктуры Rollup во многом способствовало его успеху в экосистеме. На данный момент мы считаем, что Rollup предлагает лучшее соотношение производительности и гибкости.

Rollup также работает над улучшением производительности, [переключая свой парсер на SWC в v4](https://github.com/rollup/rollup/pull/5073). И есть продолжающаяся работа над созданием порта Rollup на Rust под названием Rolldown. Как только Rolldown будет готов, он может заменить как Rollup, так и esbuild в Vite, значительно улучшив производительность сборки и устранив несоответствия между разработкой и сборкой. Вы можете посмотреть [ключевой доклад Эвана Ю на ViteConf 2023 для более подробной информации](https://youtu.be/hrdwQHoAp0M).

## Как Vite соотносится с другими инструментами сборки без бандлинга?

[WMR](https://github.com/preactjs/wmr) от команды Preact стремился предоставить аналогичный набор функций. Универсальный API плагинов Rollup для dev и сборки Vite был вдохновлен им. WMR больше не поддерживается. Команда Preact теперь рекомендует Vite с [@preactjs/preset-vite](https://github.com/preactjs/preset-vite).

[Snowpack](https://www.snowpack.dev/) также был dev-сервером без бандлинга на основе нативного ESM, очень похожим по охвату на Vite. Предварительная сборка зависимостей Vite также вдохновлена Snowpack v1 (теперь [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Snowpack больше не поддерживается. Команда Snowpack теперь работает над [Astro](https://astro.build/), генератором статических сайтов на основе Vite.

[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (ранее `es-dev-server`) - отличный проект, и настройка сервера Vite 1.0 на основе Koa была вдохновлена им. Проект `@web` активно поддерживается и содержит множество других отличных инструментов, которые могут принести пользу пользователям Vite.
